<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx" applicationComplete="initApp(event)" showStatusBar="false" width="1920" height="1080" xmlns:local="*">
	<fx:Script>
		<![CDATA[
			import com.daveoncode.logging.LogFileTarget;
			import com.phidgets.PhidgetInterfaceKit;
			import com.phidgets.events.PhidgetDataEvent;
			import com.phidgets.events.PhidgetEvent;
			
			import flash.utils.clearInterval;
			import flash.utils.setInterval;
			
			import mx.events.FlexEvent;
			import mx.logging.ILogger;
			import mx.logging.Log;
			import mx.logging.LogEventLevel;
			
			import org.osmf.events.TimeEvent;
			
			import spark.components.RichEditableText;
			
			private var phid:PhidgetInterfaceKit;
			private var lastReadData:Number;
			private var resetInterval:Number;
			private const RESET_INTERVAL_VALUE:Number = 15000;
			private const STEP_TIME:Number = 2000;
			private const LOW_LIMIT:Number = 486;
			private const HIGH_LIMIT:Number = 514;
			private const INPUT_INDEX:Number = 6;
			private const PIXEL_INCREMENT:Number = 13;
			private const TEMPERATURE_STEP:Number = 15;
			
			[Bindable] private var temperatureLevel:Number = 500;
			[Bindable] private var tempTable:Dictionary = new Dictionary();
			[Bindable] private var videoSource:String;
			
			[Bindable] private var maxReadVal:Number = 500;
			[Bindable] private var minReadVal:Number = 500;
			
			private var countingUp:Boolean = false;
			private var countingDown:Boolean = false;
			
			private var warmingInterval:Number;
			private var coolingInterval:Number;
			
			private var logger:ILogger;
						
			protected function initApp(event:FlexEvent):void {
				stage.displayState = StageDisplayState.FULL_SCREEN;
				
				// get LogFileTarget's instance (LogFileTarget is a singleton)
				var target:LogFileTarget = LogFileTarget.getInstance();
				// The log file will be placed under applicationStorageDirectory folder
				target.file = File.desktopDirectory.resolvePath("miracleME.log");
				// optional (default to "MM/DD/YY")
				target.dateFormat = "DD/MM/YYYY"; 
				// optional  (default to 1024)
				target.sizeLimit = 1000000000000;
				// Trace all (default Flex's framework features)
				target.filters = ["*"];
				target.level = LogEventLevel.INFO;
				// Begin logging  (default Flex's framework features)
				Log.addTarget(target);
				
				logger = Log.getLogger( getQualifiedClassName(MiracleME).replace("::", ".") );
				logger.info("APPLICATION_START");
				
				tempTable[305] = 5;
				tempTable[320] = 6;
				tempTable[335] = 7;
				tempTable[350] = 8;
				tempTable[365] = 9;
				tempTable[380] = 10;
				tempTable[395] = 11;
				tempTable[410] = 12;
				tempTable[425] = 13;
				tempTable[440] = 14;
				tempTable[455] = 15;
				tempTable[470] = 16;
				tempTable[485] = 17;
				tempTable[500] = 18;
				tempTable[515] = 19;
				tempTable[530] = 20;
				tempTable[545] = 21;
				tempTable[560] = 22;
				tempTable[575] = 23;
				tempTable[590] = 24;
				tempTable[605] = 25;
				tempTable[620] = 26;
				tempTable[635] = 27;
				tempTable[650] = 28;
				tempTable[665] = 29;
				tempTable[680] = 30;
				tempTable[695] = 31;
				
				phid = new PhidgetInterfaceKit();
				phid.addEventListener(PhidgetEvent.CONNECT,	onConnect);
				phid.addEventListener(PhidgetEvent.DETACH,	onDetach);
				phid.addEventListener(PhidgetEvent.DISCONNECT, onDisconnect);
				phid.addEventListener(PhidgetDataEvent.SENSOR_CHANGE, onSensorChange);
				phid.open("localhost", 5001);
			}
			
			private function onDetach(evt:PhidgetEvent):void{
				trace("Detached");
			}
			
			private function onDisconnect(evt:PhidgetEvent):void{
				trace("Disconnected");
			}
			
			private function onConnect(evt:PhidgetEvent):void{
				trace("Connected");
			}
			
			private function onSensorChange(evt:PhidgetDataEvent):void {
				lastReadData = new Number(evt.Data);
				
				if(lastReadData > maxReadVal) {
					maxReadVal = lastReadData;
				}
				
				if(lastReadData < minReadVal && lastReadData != 0) {
					minReadVal = lastReadData;
				}
				
				trace(lastReadData);
				switch(currentState) {
					case "welcome":
						if(evt.Index == INPUT_INDEX && (lastReadData > HIGH_LIMIT || lastReadData < LOW_LIMIT)) {
							currentState = "simulation";
							updateIndicator(500);
							swfHP.Temp.tOut.tempOutText.text = tempTable[500];
							swfHP.Temp.tOut.y = 75 - (tempTable[500]-tempTable[305])*PIXEL_INCREMENT;
						}
						break;
					case "simulation":
						if(evt.Index == INPUT_INDEX) {
							if(lastReadData > HIGH_LIMIT) {
								swfHP.mv_default.visible = false;
								swfHP.mv_red.visible = true;
								swfHP.mv_blue.visible = false;
								videoSource = "assets/vids/hpf.mp4";
							}
							else if(lastReadData < LOW_LIMIT) {
								swfHP.mv_default.visible = false;
								swfHP.mv_red.visible = false;
								swfHP.mv_blue.visible = true;
								videoSource = "assets/vids/hp.mp4";
							}
							
							processReadData(lastReadData);
							readVal.text = new String(evt.Data);
							tempVal.text = tempTable[temperatureLevel];	
						}
						break;
				}
			}
			
			protected function resetApp():void {
				clearInterval(resetInterval);
				currentState = "welcome";
				
			}
			
			protected function processReadData(dat:Number):void {
				clearInterval(resetInterval);
				
				if(temperatureLevel == 500 && tempVal.text == tempTable[500] && (dat > LOW_LIMIT && dat < HIGH_LIMIT)) {
					trace("standby mode");
					clearInterval(warmingInterval);
					clearInterval(coolingInterval);
					countingUp = false;
					countingDown = false;
					videoSource = "";
					resetInterval = setInterval(resetApp, RESET_INTERVAL_VALUE);
				}
				else {
					txtAnim.resume();
					
					if(dat > temperatureLevel && !countingUp) {
						trace("up temperature detected");
						clearInterval(coolingInterval);
						countingUp = true;
						countingDown = false;
						warmingInterval = setInterval(increaseTemp, STEP_TIME);
					}
					if(dat < temperatureLevel && !countingDown) {
						trace("down temperature detected");
						clearInterval(warmingInterval);
						countingUp = false;
						countingDown = true;
						coolingInterval = setInterval(decreaseTemp, STEP_TIME);
					}
				}

				if(dat > LOW_LIMIT && dat < HIGH_LIMIT) {
					txtAnim.pause();
					swfHP.mv_default.visible = true;
					swfHP.mv_red.visible = false;
					swfHP.mv_blue.visible = false;
				}
			}
			
			protected function increaseTemp():void {
				clearInterval(warmingInterval);
				temperatureLevel = temperatureLevel + TEMPERATURE_STEP;
				trace("temperature increase: "+temperatureLevel);
				countingUp = false;
				tempVal.text = tempTable[temperatureLevel];
				updateIndicator(temperatureLevel);
				processReadData(lastReadData);
			}
			
			protected function updateIndicator(temp:Number):void {
				swfHP.Temp.tHus.tempHusText.text = tempTable[temp];
				swfHP.Temp.tHus.y = 75 - (tempTable[temp]-tempTable[305])*PIXEL_INCREMENT;
			}
			
			protected function decreaseTemp():void {
				clearInterval(coolingInterval);
				temperatureLevel = temperatureLevel - TEMPERATURE_STEP;
				trace("temperature decrease: "+temperatureLevel);
				countingDown = false;
				tempVal.text = tempTable[temperatureLevel];
				updateIndicator(temperatureLevel);
				processReadData(lastReadData);
			}
			
			protected function videoPlayer_durationChangeHandler(event:TimeEvent):void {
				fadeIn.play();
			}
			
			protected function placeCorrectPicture():void {
				if(videoSource == "assets/vids/hpf.mp4") {
					bckImage.source = "assets/pics/cold.png";
				}
				else {
					bckImage.source = "assets/pics/hot.png";
				}				
			}
			
			protected function initTxt(event:FlexEvent):void {
				txtAnim.stop();
				pth.valueFrom = 0;
				pth.valueTo = (banner.textDisplay as RichEditableText).contentWidth - (banner.textDisplay as RichEditableText).width;
				txtAnim.play([banner.textDisplay]);
				txtAnim.pause();
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<s:Fade id="fadeIn" alphaFrom="0.1" alphaTo="1" duration="3000" target="{videoPlayer}">
			<s:effectEnd>
				<![CDATA[
					placeCorrectPicture();
				]]>
			</s:effectEnd>
		</s:Fade>
		
		<s:Fade id="splashFadeIn" alphaFrom="0" alphaTo="1" duration="1500" />
		<s:Fade id="splashFadeOut" alphaFrom="1" alphaTo="0" duration="1500" />
		
		<s:Animate id="txtAnim" duration="30000" repeatCount="0" repeatBehavior="loop" repeatDelay="2000" easer="{null}">
			<s:motionPaths>
				<s:SimpleMotionPath id="pth" property="horizontalScrollPosition" />
			</s:motionPaths>
		</s:Animate>
	</fx:Declarations>
	
	<s:states>
		<s:State name="welcome" />
		<s:State name="simulation" />
	</s:states>
	
	<s:Group width="1920" height="1080" includeIn="simulation">
		<s:Group left="668" top="180">
			<s:Image id="bckImage" />
			<s:VideoDisplay id="videoPlayer" source="{videoSource}" width="580" height="836" autoPlay="true" loop="true" durationChange="fadeIn.play()" />
		</s:Group>
		<local:HP_FLEX id="swfHP"/>
		<s:Group width="100%" height="150">
			<s:Rect width="100%" height="100%">
				<s:fill>
					<s:SolidColor color="#FFFFFF" />
				</s:fill>
			</s:Rect>
			<s:TextInput id="banner" text="This is a very long text which needs to scroll over and over again and which needs to stop whenever someone stops cranking the physical exhibit, located not far from the miniature house."
						 editable="false" fontSize="40"
						 width="800" horizontalCenter="0" bottom="20" creationComplete="initTxt(event)" />
		</s:Group>
		<s:VGroup horizontalAlign="center">
			<s:HGroup>
				<s:Label fontSize="20" id="readVal" />
				<s:Label fontSize="20" text="{'(max: '+maxReadVal+')'}" />
				<s:Label fontSize="20" text="{'(min: '+minReadVal+')'}" />
			</s:HGroup>
			<s:Label fontSize="20" id="tempVal" />
		</s:VGroup>
	</s:Group>

	<s:Group id="splashGroup" width="100%" height="100%" visible.welcome="true" visible.simulation="false" hideEffect="splashFadeOut" showEffect="splashFadeIn">
		<s:Image horizontalCenter="0" verticalCenter="0" source="@Embed('assets/pics/splash.jpg')" cacheAsBitmap="true" />
	</s:Group>
</s:WindowedApplication>
