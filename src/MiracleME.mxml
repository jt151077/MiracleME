<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx" applicationComplete="initApp(event)" showStatusBar="false" width="1920" height="1080" xmlns:local="*">
	<fx:Script>
		<![CDATA[
			import com.daveoncode.logging.LogFileTarget;
			import com.phidgets.PhidgetInterfaceKit;
			import com.phidgets.events.PhidgetDataEvent;
			import com.phidgets.events.PhidgetEvent;
			
			import flash.utils.clearInterval;
			import flash.utils.setInterval;
			
			import mx.events.FlexEvent;
			import mx.logging.ILogger;
			import mx.logging.Log;
			import mx.logging.LogEventLevel;
			
			import org.osmf.events.TimeEvent;
			
			private var phid:PhidgetInterfaceKit;
			private var lastReadData:Number;
			private var resetInterval:Number;
			private const RESET_INTERVAL_VALUE:Number = 15000;
			private const STEP_TIME:Number = 2000;
			private const LOW_LIMIT:Number = 486;
			private const HIGH_LIMIT:Number = 514;
			private const INPUT_INDEX:Number = 6;
			private const PIXEL_INCREMENT:Number = 13;
			private const TEMPERATURE_STEP:Number = 15;
			
			[Bindable] private var temperatureLevel:Number = 500;
			[Bindable] private var tempTable:Dictionary = new Dictionary();
			[Bindable] private var videoSource:String;
			
			[Bindable] private var maxReadVal:Number = 500;
			[Bindable] private var minReadVal:Number = 500;
			
			private var countingUp:Boolean = false;
			private var countingDown:Boolean = false;
			
			private var warmingInterval:Number;
			private var coolingInterval:Number;
			
			private var logger:ILogger;
						
			protected function initApp(event:FlexEvent):void {
				stage.displayState = StageDisplayState.FULL_SCREEN;
				
				// get LogFileTarget's instance (LogFileTarget is a singleton)
				var target:LogFileTarget = LogFileTarget.getInstance();
				// The log file will be placed under applicationStorageDirectory folder
				target.file = File.desktopDirectory.resolvePath("miracleME.log");
				// optional (default to "MM/DD/YY")
				target.dateFormat = "DD/MM/YYYY"; 
				// optional  (default to 1024)
				target.sizeLimit = 1000000000000;
				// Trace all (default Flex's framework features)
				target.filters = ["*"];
				target.level = LogEventLevel.INFO;
				// Begin logging  (default Flex's framework features)
				Log.addTarget(target);
				
				logger = Log.getLogger( getQualifiedClassName(MiracleME).replace("::", ".") );
				logger.info("APPLICATION_START");
				
				tempTable[305] = 5;
				tempTable[320] = 6;
				tempTable[335] = 7;
				tempTable[350] = 8;
				tempTable[365] = 9;
				tempTable[380] = 10;
				tempTable[395] = 11;
				tempTable[410] = 12;
				tempTable[425] = 13;
				tempTable[440] = 14;
				tempTable[455] = 15;
				tempTable[470] = 16;
				tempTable[485] = 17;
				tempTable[500] = 18;
				tempTable[515] = 19;
				tempTable[530] = 20;
				tempTable[545] = 21;
				tempTable[560] = 22;
				tempTable[575] = 23;
				tempTable[590] = 24;
				tempTable[605] = 25;
				tempTable[620] = 26;
				tempTable[635] = 27;
				tempTable[650] = 28;
				tempTable[665] = 29;
				tempTable[680] = 30;
				tempTable[695] = 31;
				
				phid = new PhidgetInterfaceKit();
				phid.addEventListener(PhidgetEvent.CONNECT,	onConnect);
				phid.addEventListener(PhidgetEvent.DETACH,	onDetach);
				phid.addEventListener(PhidgetEvent.DISCONNECT, onDisconnect);
				phid.addEventListener(PhidgetDataEvent.SENSOR_CHANGE, onSensorChange);
				phid.open("localhost", 5001);
			}
			
			private function onDetach(evt:PhidgetEvent):void{
				trace("Detached");
			}
			
			private function onDisconnect(evt:PhidgetEvent):void{
				trace("Disconnected");
			}
			
			private function onConnect(evt:PhidgetEvent):void{
				trace("Connected");
			}
			
			private function onSensorChange(evt:PhidgetDataEvent):void {
				lastReadData = new Number(evt.Data);
				
				if(lastReadData > maxReadVal) {
					maxReadVal = lastReadData;
				}
				
				if(lastReadData < minReadVal && lastReadData != 0) {
					minReadVal = lastReadData;
				}
				
				trace(lastReadData);
				switch(currentState) {
					case "welcome":
						if(evt.Index == INPUT_INDEX && (lastReadData > HIGH_LIMIT || lastReadData < LOW_LIMIT)) {
							currentState = "simulation";
							updateIndicator(500);
							swfHP.Temp.tOut.tempOutText.text = tempTable[500];
							swfHP.Temp.tOut.y = 75 - (tempTable[500]-tempTable[305])*PIXEL_INCREMENT;
						}
						break;
					case "simulation":
						if(evt.Index == INPUT_INDEX) {
							if(lastReadData > HIGH_LIMIT) {
								swfHP.mv_default.visible = false;
								swfHP.mv_red.visible = true;
								swfHP.mv_blue.visible = false;
								videoSource = "assets/vids/hpf.mp4";
							}
							else if(lastReadData < LOW_LIMIT) {
								swfHP.mv_default.visible = false;
								swfHP.mv_red.visible = false;
								swfHP.mv_blue.visible = true;
								videoSource = "assets/vids/hp.mp4";
							}
							
							processReadData(lastReadData);
							readVal.text = new String(evt.Data);
							tempVal.text = tempTable[temperatureLevel];	
						}
						break;
				}
			}
			
			protected function resetApp():void {
				clearInterval(resetInterval);
				currentState = "welcome";
				
			}
			
			protected function processReadData(dat:Number):void {
				clearInterval(resetInterval);
				
				if(dat > LOW_LIMIT && dat < HIGH_LIMIT) {
					swfHP.mv_default.visible = true;
					swfHP.mv_red.visible = false;
					swfHP.mv_blue.visible = false;
				}
				
				if(temperatureLevel == 500 && tempVal.text == tempTable[500] && (dat > LOW_LIMIT && dat < HIGH_LIMIT)) {
					trace("standby mode");
					clearInterval(warmingInterval);
					clearInterval(coolingInterval);
					countingUp = false;
					countingDown = false;
					videoSource = "";
					resetInterval = setInterval(resetApp, RESET_INTERVAL_VALUE);
				}
				else {
					if(dat > temperatureLevel && !countingUp) {
						trace("up temperature detected");
						clearInterval(coolingInterval);
						countingUp = true;
						countingDown = false;
						warmingInterval = setInterval(increaseTemp, STEP_TIME);
					}
					if(dat < temperatureLevel && !countingDown) {
						trace("down temperature detected");
						clearInterval(warmingInterval);
						countingUp = false;
						countingDown = true;
						coolingInterval = setInterval(decreaseTemp, STEP_TIME);
					}
				}
			}
			
			protected function increaseTemp():void {
				clearInterval(warmingInterval);
				temperatureLevel = temperatureLevel + TEMPERATURE_STEP;
				trace("temperature increase: "+temperatureLevel);
				countingUp = false;
				tempVal.text = tempTable[temperatureLevel];
				updateIndicator(temperatureLevel);
				processReadData(lastReadData);
			}
			
			protected function updateIndicator(temp:Number):void {
				swfHP.Temp.tHus.tempHusText.text = tempTable[temp];
				swfHP.Temp.tHus.y = 75 - (tempTable[temp]-tempTable[305])*PIXEL_INCREMENT;
			}
			
			protected function decreaseTemp():void {
				clearInterval(coolingInterval);
				temperatureLevel = temperatureLevel - TEMPERATURE_STEP;
				trace("temperature decrease: "+temperatureLevel);
				countingDown = false;
				tempVal.text = tempTable[temperatureLevel];
				updateIndicator(temperatureLevel);
				processReadData(lastReadData);
			}
			
			protected function videoPlayer_durationChangeHandler(event:TimeEvent):void {
				fadeIn.play();
			}
			
			protected function placeCorrectPicture():void {
				if(videoSource == "assets/vids/hpf.mp4") {
					bckImage.source = "assets/pics/cold.png";
				}
				else {
					bckImage.source = "assets/pics/hot.png";
				}				
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<s:Fade id="fadeIn" alphaFrom="0.1" alphaTo="1" duration="3000" target="{videoPlayer}">
			<s:effectEnd>
				<![CDATA[
					placeCorrectPicture();
				]]>
			</s:effectEnd>
		</s:Fade>
		
		<s:Fade id="splashFadeIn" alphaFrom="0" alphaTo="1" duration="1500" />
		<s:Fade id="splashFadeOut" alphaFrom="1" alphaTo="0" duration="1500" />
	</fx:Declarations>
	
	<s:states>
		<s:State name="welcome" />
		<s:State name="simulation" />
	</s:states>
	
	<s:Group width="1920" height="1080" includeIn="simulation">
		<s:Group left="668" top="180">
			<s:Image id="bckImage" />
			<s:VideoDisplay id="videoPlayer" source="{videoSource}" width="580" height="836" autoPlay="true" loop="true" durationChange="fadeIn.play()" />
		</s:Group>
		<s:VGroup horizontalAlign="center">
			<s:HGroup>
				<s:Label fontSize="20" id="readVal" />
				<s:Label fontSize="20" text="{'(max: '+maxReadVal+')'}" />
				<s:Label fontSize="20" text="{'(min: '+minReadVal+')'}" />
			</s:HGroup>
			<s:Label fontSize="20" id="tempVal" />
		</s:VGroup>
		<local:HP_FLEX id="swfHP"/>
	</s:Group>

	<s:Group id="splashGroup" width="100%" height="100%" visible.welcome="true" visible.simulation="false" hideEffect="splashFadeOut" showEffect="splashFadeIn">
		<s:Image horizontalCenter="0" verticalCenter="0" source="@Embed('assets/pics/splash.jpg')" cacheAsBitmap="true" />
	</s:Group>
</s:WindowedApplication>
